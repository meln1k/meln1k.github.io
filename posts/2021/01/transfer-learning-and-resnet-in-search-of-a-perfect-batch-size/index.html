<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Nikita Melkozerov"><meta name=generator content="Hugo 0.55.6"><title>Transfer Learning and ResNet: In search of a perfect batch size — Nikita Melkozerov</title><meta name=description content="How different batch sizes affect learning when using ResNet image classifiers."><link rel=canonical href=https://nikita.melkozerov.dev/posts/2021/01/transfer-learning-and-resnet-in-search-of-a-perfect-batch-size/><link href rel=alternate type=application/rss+xml title="Nikita Melkozerov"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,700|Source+Code+Pro|Arvo:700"><link rel=stylesheet href=https://nikita.melkozerov.dev/css/paperback.css><link rel=stylesheet type=text/css href=https://nikita.melkozerov.dev/css/syntax.css></head><body><div class=container><header><h1>Transfer Learning and ResNet: In search of a perfect batch size</h1><time datetime="2021-01-06 10:20:25 &#43;0000 UTC">2021/01/06</time></header><article><p>TL;DR: <em>batch size 32 is probably going to be a good default candidate for many cases.</em></p><p>In this post, we will observe how different batch sizes change learning metrics when we train a model using Transfer Learning and the fast.ai library. We will try to find out which batch sizes are good and which are better to be avoided.</p><h1 id=getting-the-dataset>Getting the dataset</h1><p>Recently I was going through the awesome <a href=https://course.fast.ai/>fast.ai deep learning course</a>, and in one of the lectures we were building a classifier that can recognize cats and dogs. I wanted to build one too, and since I live in Hamburg I decided to go with some birds one can see there. Fortunately, there was a <a href=https://myzoneisbirding.wordpress.com/2018/05/01/hamburg-germany-08-04-15-04-2018/>post by Luca Feuerriegel</a> where I found the names of some of the species: <em>European Robin</em>, <em>Marsh Tit</em>, <em>Eurasian Blackbird</em>, <em>Eurasian Nuthatch</em>, <em>Eurasian Jay</em>, <em>Eurasian Wren</em>, <em>Hawfinch</em>, <em>Bullfinch</em>, <em>Common Starling</em>, <em>Greylag Goose</em>, <em>Barnacle Goose</em>, <em>Meadow Pipit</em>, <em>Common Wood Pigeon</em>, <em>Mistle Thrush</em>.</p><p>To collect the dataset, I used the bing image search to get images of every bird mentioned above. I&rsquo;m not going to publish the collected images since I have doubts about violating copyright, however, you can download the <a href=https://github.com/meln1k/deep-learning-experiments/blob/main/block-size-and-learning-rate/HamburgBirds.ipynb>source code of the notebook</a> and run the experiment yourself.</p><p>After I collected the dataset, I did a few training iterations and cleaned the dataset using the <code>ImageClassifierCleaner</code> tool in the fast.ai library.</p><p>In the end, I ended up with 2017 pictures representing 14 different species of birds, which should be good enough to train the model fast and not overfit too quickly.</p><h1 id=training-the-model>Training the model</h1><p>To obtain the results we&rsquo;re going to experiment with 3 ResNet architectures: ResNet50, ResNet34, and ResNet18. For each architecture, we will train the model 10 times with batch sizes of 128, 64, 32, 16, 8, and 4. We will also train the model for 10 epochs for each combination of the architecture and batch size.</p><p>We&rsquo;re also going to apply a few transformations and data augmentation steps to avoid overfitting: randomly cropping and resizing the images, and applying a standard set of batch augmentation (<code>aug_transforms()</code>):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=n>birdsDB</span> <span class=o>=</span> <span class=n>DataBlock</span><span class=p>(</span>
    <span class=n>blocks</span><span class=o>=</span><span class=p>(</span><span class=n>ImageBlock</span><span class=p>,</span> <span class=n>CategoryBlock</span><span class=p>),</span>
    <span class=n>get_items</span><span class=o>=</span><span class=n>get_image_files</span><span class=p>,</span>
    <span class=n>splitter</span><span class=o>=</span><span class=n>RandomSplitter</span><span class=p>(</span><span class=n>valid_pct</span><span class=o>=</span><span class=mf>0.2</span><span class=p>,</span> <span class=n>seed</span><span class=o>=</span><span class=mi>1337</span><span class=p>),</span>
    <span class=n>get_y</span><span class=o>=</span><span class=n>parent_label</span><span class=p>,</span>
    <span class=n>item_tfms</span><span class=o>=</span><span class=n>RandomResizedCrop</span><span class=p>(</span><span class=mi>224</span><span class=p>,</span> <span class=n>min_scale</span><span class=o>=</span><span class=mf>0.5</span><span class=p>),</span>
    <span class=n>batch_tfms</span><span class=o>=</span><span class=n>aug_transforms</span><span class=p>())</span></code></pre></td></tr></table></div></div><p>The other parameters will be left to default. We will also use a <code>CSVLogger</code> callback to save the learning metrics to the CSV files which we will analyze later.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>train</span><span class=p>(</span><span class=n>arch</span><span class=p>,</span> <span class=n>batch_size</span><span class=p>,</span> <span class=n>index</span><span class=p>):</span>
    <span class=n>dls</span> <span class=o>=</span> <span class=n>birdsDB</span><span class=o>.</span><span class=n>dataloaders</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=n>bs</span><span class=o>=</span><span class=n>batch_size</span><span class=p>)</span>
    <span class=n>learn</span> <span class=o>=</span> <span class=n>cnn_learner</span><span class=p>(</span><span class=n>dls</span><span class=p>,</span> <span class=n>architectures</span><span class=p>[</span><span class=n>arch</span><span class=p>],</span> <span class=n>metrics</span><span class=o>=</span><span class=n>error_rate</span><span class=p>,</span> <span class=n>cbs</span><span class=o>=</span><span class=p>[</span><span class=n>ShowGraphCallback</span><span class=p>,</span> <span class=n>CSVLogger</span><span class=p>(</span><span class=n>fname</span><span class=o>=</span><span class=n>f</span><span class=s1>&#39;birds-{arch}-bs{batch_size}-{index}.csv&#39;</span><span class=p>)])</span><span class=o>.</span><span class=n>to_fp16</span><span class=p>()</span>
    <span class=n>learn</span><span class=o>.</span><span class=n>fine_tune</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span></code></pre></td></tr></table></div></div><p>We will also train with half-precision to fit ResNet50 with 128 batch size into my GPU.</p><p>Finally this is our nested loop where we will try different parameters:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=k>for</span> <span class=n>arch</span> <span class=ow>in</span> <span class=p>[</span><span class=s1>&#39;rn50&#39;</span><span class=p>,</span> <span class=s1>&#39;rn34&#39;</span><span class=p>,</span> <span class=s1>&#39;rn18&#39;</span><span class=p>]:</span>
    <span class=k>for</span> <span class=n>bs</span> <span class=ow>in</span> <span class=p>[</span><span class=mi>128</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>4</span><span class=p>]:</span>
        <span class=k>for</span> <span class=n>index</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>):</span>
            <span class=n>train</span><span class=p>(</span><span class=n>arch</span><span class=p>,</span> <span class=n>bs</span><span class=p>,</span> <span class=n>index</span><span class=p>)</span>
            <span class=n>torch</span><span class=o>.</span><span class=n>cuda</span><span class=o>.</span><span class=n>empty_cache</span><span class=p>()</span>
            <span class=n>gc</span><span class=o>.</span><span class=n>collect</span><span class=p>()</span></code></pre></td></tr></table></div></div><p>It is worth noting that this loop took around 6 hours to finish, so be patient if you would like to experiment yourself :)</p><h1 id=analyzing-the-results>Analyzing the results</h1><p>After waiting for a few hours, we finally have all 180 CSV files ready for analysis. Yay!</p><p>Let&rsquo;s dig into them.</p><p>First we would need a function to parse the CSV file and convert it into a pandas dataframe:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>loadLog</span><span class=p>(</span><span class=n>bs</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>arch</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>idx</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>:</span>
    <span class=n>df</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>read_csv</span><span class=p>(</span><span class=n>f</span><span class=s2>&#34;birds-{arch}-bs{bs}-{idx}.csv&#34;</span><span class=p>)</span>
    <span class=c1># change the time to seconds</span>
    <span class=c1># since no training epoch took more than 1 minute </span>
    <span class=c1># we will cheat and simply trim the minutes away</span>
    <span class=n>df</span><span class=p>[</span><span class=s1>&#39;time&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>df</span><span class=o>.</span><span class=nb>apply</span><span class=p>(</span><span class=k>lambda</span> <span class=n>df</span><span class=p>:</span> <span class=nb>int</span><span class=p>(</span><span class=n>df</span><span class=p>[</span><span class=s1>&#39;time&#39;</span><span class=p>]</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;:&#39;</span><span class=p>)[</span><span class=mi>1</span><span class=p>]),</span> <span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>df</span></code></pre></td></tr></table></div></div><p>Then, because we have 10 dataframes per each combination of a batch size and an architecture, we will merge them together and calculate the average:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>loadMergedLog</span><span class=p>(</span><span class=n>bs</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>arch</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>:</span>
    <span class=n>dfs</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>idx</span><span class=p>:</span> <span class=n>loadLog</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=n>arch</span><span class=p>,</span> <span class=n>idx</span><span class=p>),</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>
    <span class=n>merged</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>concat</span><span class=p>(</span><span class=n>dfs</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>merged</span><span class=o>.</span><span class=n>groupby</span><span class=p>(</span><span class=n>merged</span><span class=o>.</span><span class=n>index</span><span class=p>)</span><span class=o>.</span><span class=n>mean</span><span class=p>()</span></code></pre></td></tr></table></div></div><p>Finally, we need a function that will plot the results:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>plotResults</span><span class=p>(</span><span class=n>arch</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>y_axis</span><span class=p>:</span> <span class=nb>str</span><span class=p>):</span>
    <span class=n>fig</span><span class=p>,</span> <span class=n>ax</span> <span class=o>=</span> <span class=n>plt</span><span class=o>.</span><span class=n>subplots</span><span class=p>()</span>

    <span class=n>fig</span><span class=o>.</span><span class=n>set_size_inches</span><span class=p>(</span><span class=mi>20</span><span class=p>,</span><span class=mi>15</span><span class=p>)</span>

    <span class=n>blockSizes</span> <span class=o>=</span> <span class=p>[</span><span class=mi>128</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>4</span><span class=p>]</span>

    <span class=k>for</span> <span class=n>bs</span> <span class=ow>in</span> <span class=n>blockSizes</span><span class=p>:</span>
        <span class=n>frame</span> <span class=o>=</span> <span class=n>loadMergedLog</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=n>arch</span><span class=p>)</span>
        <span class=n>plt</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>frame</span><span class=p>[</span><span class=s1>&#39;epoch&#39;</span><span class=p>],</span> <span class=n>frame</span><span class=p>[</span><span class=n>y_axis</span><span class=p>])</span>
        <span class=n>ax</span><span class=o>.</span><span class=n>legend</span><span class=p>(</span><span class=n>blockSizes</span><span class=p>);</span>

    <span class=n>ax</span><span class=o>.</span><span class=n>legend</span><span class=p>(</span><span class=n>blockSizes</span><span class=p>);</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>xlim</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>9</span><span class=p>)</span>
    <span class=n>plt</span><span class=o>.</span><span class=n>show</span><span class=p>()</span></code></pre></td></tr></table></div></div><p>With all this in place, let&rsquo;s see how the batch size was affecting the training:</p><h3 id=resnet50>ResNet50</h3><p>Let&rsquo;s start with the error rate:</p><p><img src=/images/transfer-learning-batch-size-experiment/rn50-errors.png alt="ResNet50 errors"></p><p>Here we see that batch sizes 4 and 8 are not that good, and 32 gave us the lowest error after 10 epochs of training.</p><p>Now let&rsquo;s look at the training time:</p><p><img src=/images/transfer-learning-batch-size-experiment/rn50-time.png alt="ResNet50 training time"></p><p>Unsurprisingly, batch sizes 4 and 8 were slow due to copying overhead, while batch sizes of 32 and 64 were the fastest. Interestingly, a batch size of 128 was also slower than 32 and 64.</p><h3 id=resnet34>ResNet34</h3><p>With a reduced number of layers the model error rate seems to follow the same pattern as before: batch size 32 looking better than the others (however not that much) and batch size 4 again showed the lowest performance.</p><p><img src=/images/transfer-learning-batch-size-experiment/rn34-errors.png alt="ResNet34 errors"></p><p>Speaking of training time we see the same picture: batch sizes of 32 and 64 being the fastest, and 4 being the slowest.</p><p><img src=/images/transfer-learning-batch-size-experiment/rn34-time.png alt="ResNet34 training time"></p><p>Initially, the learning performance doubles when we double the batch size (bs16 is twice as fast as bs8, and bs8 is twice as fast as bs4), and stabilizes around 32 and 62 images per batch.</p><h3 id=resnet18>ResNet18</h3><p>When we train the model using an even smaller ResNet architecture, our previous results are confirmed again:</p><p><img src=/images/transfer-learning-batch-size-experiment/rn18-errors.png alt="ResNet18 errors"></p><p><img src=/images/transfer-learning-batch-size-experiment/rn18-time.png alt="ResNet18 training time"></p><p>Learning was the fastest with batch size 32, and the performance of all three 16, 32, and 64 batch sizes are very similar.</p><h1 id=results>Results</h1><p>We trained the classifier on the natural images resized to 224 pixels, and discovered that batch size 32 was often surpassing other candidates in terms of learning speed and error rate.</p><p>This means that it is probably going to be a good default candidate when we try to analyze natural images and want to iterate quickly, for example when wanting to clean up the dataset.</p><p>Batch sizes of 8 and less are probably better be avoided if your images are small due to high overhead on data transfer.</p><p>Training with a batch size of 128 was slower and a bit less accurate, so it might not be the ideal candidate to start with.</p></article><section class=comments-block><button id=show-comments class=comments-button style=display:none>Load Disqus Comments</button></section><section id=disqus_thread></section><script>(function(){if(window.location.hostname=="localhost")
return;var disqus_loaded=false;var disqus_shortname='meln1k';var disqus_button=document.getElementById("show-comments");disqus_button.style.display="";disqus_button.addEventListener("click",disqus,false);function disqus(){if(!disqus_loaded){disqus_loaded=true;var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e);document.getElementById("show-comments").style.display="none";}}
var hash=window.location.hash.substr(1);if(hash.length>8){if(hash.substring(0,8)=="comment-"){disqus();}}})();</script><nav class=site-nav><a href=https://nikita.melkozerov.dev/>Home</a>
<a href=https://nikita.melkozerov.dev/posts/>All posts</a>
<a href=https://twitter.com/meln1k>Twitter</a>
<a href=https://github.com/meln1k>GitHub</a>
<a href=https://www.linkedin.com/in/nmelkozerov>LinkedIn</a></nav><footer class=site-footer><span class=owner>©2021 Nikita Melkozerov</span>
<script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-59947059-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></footer></div></body></html>