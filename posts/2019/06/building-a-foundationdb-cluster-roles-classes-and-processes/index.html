<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building a FoundationDB Cluster: Roles, Classes, and Processes | Nikita Melkozerov</title><meta name=keywords content="foundationdb"><meta name=description content="How to prepare your FoundationDB cluster to run it in production and set up process classes to achieve maximum performance."><meta name=author content><link rel=canonical href=https://nikita.melkozerov.dev/posts/2019/06/building-a-foundationdb-cluster-roles-classes-and-processes/><link href=/assets/css/stylesheet.min.1eef9c740af75b4e5f773d9d5f757e03e3df71f3a308e73070cc73d55a59a7d7.css integrity="sha256-Hu+cdAr3W05fdz2dX3V+A+PfcfOjCOcwcMxz1VpZp9c=" rel="preload stylesheet" as=style><link rel=icon href=https://nikita.melkozerov.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nikita.melkozerov.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nikita.melkozerov.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://nikita.melkozerov.dev/apple-touch-icon.png><link rel=mask-icon href=https://nikita.melkozerov.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-59947059-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Building a FoundationDB Cluster: Roles, Classes, and Processes"><meta property="og:description" content="How to prepare your FoundationDB cluster to run it in production and set up process classes to achieve maximum performance."><meta property="og:type" content="article"><meta property="og:url" content="https://nikita.melkozerov.dev/posts/2019/06/building-a-foundationdb-cluster-roles-classes-and-processes/"><meta property="article:published_time" content="2019-06-15T14:20:32+02:00"><meta property="article:modified_time" content="2019-06-15T14:20:32+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building a FoundationDB Cluster: Roles, Classes, and Processes"><meta name=twitter:description content="How to prepare your FoundationDB cluster to run it in production and set up process classes to achieve maximum performance."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nikita.melkozerov.dev/posts/"},{"@type":"ListItem","position":2,"name":"Building a FoundationDB Cluster: Roles, Classes, and Processes","item":"https://nikita.melkozerov.dev/posts/2019/06/building-a-foundationdb-cluster-roles-classes-and-processes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building a FoundationDB Cluster: Roles, Classes, and Processes","name":"Building a FoundationDB Cluster: Roles, Classes, and Processes","description":"How to prepare your FoundationDB cluster to run it in production and set up process classes to achieve maximum performance.\n","keywords":["foundationdb"],"articleBody":"How to prepare your FoundationDB cluster to run it in production and set up process classes to achieve maximum performance.\nFoundationDB is an outstanding database and it is a joy to use it as a developer. However, when it comes to running FDB in production, it is not always clear how many instances are needed and what classes should be assigned to processes. As of June 2019, FoundationDB doesn’t (yet) have a “smart” tool that can automatically set the layout of the FDB cluster, and it is important to set the layout manually to achieve decent performance.\nIn this post, I’ll writte about the best practices for configuring FDB cluster which I discovered while experimenting with the database and reading FoundationDB forums.\nRoles, Classes, and Processes in FoundationDB FoundationDB server processes are identical binaries, but it is possible to assign a process to a specific class or a role to prioritize a specific workload. The difference between a class and a role is that assigning a class to a process specifies preference to recruit one of the corresponding roles (based on how good a particular role fits to a class), and assigning a role will result in a process preferring a single workload. The relationships between classes and roles are defined in the Locality.cpp file.\nOut of clutter, find simplicity While no one prevents assigning a single role to a process, it is more flexible to assign storage, transaction and stateless classes to processes. Let’s look at them more closely:\nStorage class: best fit for the storage role, worst fit for the transaction log role. Other roles won’t be recruited in a process with this class.\nTransaction class: good fit for the transaction log role, okay fit for the proxy, resolver, log router, cluster controller roles, worst fit for the storage role.\nStateless class: good fit for the proxy, master, resolver, log router, cluster controller, data distributor, and ratekeeper processes. Storage and transaction log roles won’t be assigned to the stateless process.\nWhen FDB tries to figure out which role it will recruit in a process, the fitness priority is used: best fit  good fit  okay fit  unset fit  worst fit  never assign. For example, if there are two processes which both have a transaction and a stateless class, the proxy role will be assigned to the stateless class since it fits better, even though transaction class is also suitable for this role.\nPlease note that assigning a role to the process will be treated as a class with the best fit for that role.\nEvery individual has a role to play for the betterment of our cluster So, if a process will be recruited for a particular role, what will it do? Let’s look at them one by one:\n Process with the storage role is responsible for storing key/value b-trees and serving reads to clients. It provides a consistent database snapshot for the last 5 seconds. A typical FDB cluster would have ~ 80-90% of all processes recruited as storage. The transaction log process keeps an append-only log of mutations for ~ 7 seconds before the changes are pulled by the storage process, then deletes them. If a storage process is not able to pull the changes in time, the disk space used by log will grow. The proxy sits between the client and transactional authority and coordinates the actions along the write transaction path. It also gives out recent read versions to the client. The master keeps track of the commit version, assigns commit versions to transactions to provide global ordering. The resolver checks transactions and aborts them if they’re conflicting. The data distributor is responsible for distributing data across shards. The ratekeeper limits the transaction rate to prevent cluster overload. The cluster controller knows the cluster configuration, provides it to new clients and reconfigures the cluster in the event of network disruption. The log router will be recruited in remote datacenters for the purpose of supporting the log replication.  Now that we know more about the classes, roles, and processes, let’s see what resource requirements different roles have.\nRequirements and resources Different process roles consume different resources such as CPU, IOPS, network bandwidth and RAM, and we need to be careful to not create resource contention that will lead to reduced performance.\nThe transaction Log is both IOPS1 and bandwidth2 hungry, and it’s important to dedicate a whole disk for it. Memory consumption is ~ 1GB3.\nThe storage is not IOPS hungry but it can saturate the CPU, so it’s better to not run the storage role in one process with others. If your SSD is fast enough, having more than one storage processes will utilize it better. It consumes less bandwidth than tLog or proxy, but it usually requires ~ 4GB of memory on average3.\nThe proxy is bandwidth2 \u0026 CPU hungry, and it is important to give this role enough CPU to keep the latencies low.\nThe resolver is involved in checking conflict ranges and if you don’t have conflicts then CPU consumption will be low4. No high bandwidth or high IOPS consumption is expected, but the memory consumption can around 1GB3.\nThe rest of the stateless processes do not consume any significant resources and can be deployed without restrictions.\nBased on the requirements above, there is a set of recommendations:\n Don’t run tLog and storage on a single disk. Don’t run anything else in a single process that has storage or proxy roles since they’re CPU hungry. Run each proxy on a different host. It might be useful to dedicate a separate host for tLog due to its bandwidth consumption. Don’t leave unspecified processes as FDB will recruit a storage role there by default5, and this can increase latency for other roles in this process.  These are not hard rules but rather recommendations that should improve the performance of your cluster. For example, if a proxy is consuming the whole CPU core but the network is not saturated, it makes sense to run another proxy process on the same host.\nBuilding the cluster Given that we understand more about roles and their requirements, let’s see what might be reasonable cluster layouts.\n2-node replication If we want to tolerate a single machine failure (and make progress after such failure), we need 3 machines with 2 copy replication. However, for performance reasons, we should not share disks between tLog and storage roles. It means that we should have 6 separate disks. Often, cloud providers will give only one disk per node, that’s why we need at least six different nodes to prevent performance penalties in the event of failure.\nA minimal Layout #1: 6 nodes, 2 processes in each node:\n tLog master tLog cluster_controller tLog stateless storage proxy storage proxy storage stateless  In this layout, we try to utilize the network bandwidth as much as possible by placing tLogs and proxies on different nodes, and at the same time, we don’t have a performance loss in case of failure because we have extra tLog and storage processes. You can easily scale this cluster by adding more storage processes, and adding more tLog, proxies, and resolver if they’re overloaded.\nA minimal Layout #2: 5 nodes, 2 processes in each node:\n tLog master tLog cluster_controller storage proxy storage proxy storage stateless  Here we use fewer nodes, however, if tLog fails FDB will relocate the missing tLog to the same process together with a storage role. This will degrade the performance and increase latencies until the node is back.\nPlease note that the ratio of tLog : storage is not optimal here and it’s done this way purely due to fault tolerance concerns. Usually, you need more storage processes than tLog processes. It depends on your workload though, if you have lots of heavy writes, then having more tLog processes is better.\nAlso, don’t forget to configure three coordinators to keep the cluster running in the event of a node failure.\n3-node replication If you’re unsure about the reliability of the available hosts, it is possible to use 3-node replication. Again, I’m making this layout given that only 1 disk is available per host, therefore we need to have 4 hosts for each tLog and storage role.\nA minimal Layout #3: 8 nodes, 2 processes in each node:\n tLog master tLog cluster_controller tLog stateless tLog stateless storage proxy storage proxy storage proxy storage resolution  With this layout we don’t share a node between the proxy and the tLog, disks aren’t shared between stateful processes, and every process has a set class so FDB won’t spawn a storage process where we wouldn’t expect it. We already have quite some tLog roles here, so to scale this cluster we should add more storage nodes.\nThat’s all, folks. I hope these layouts will make it easier to bootstrap a FoundationDB cluster. Do you have other cool ideas about the possible cluster layouts? Please share them in the comments!\n  https://forums.foundationdb.org/t/production-deployment/522/4?u=meln1k ↩︎\n https://forums.foundationdb.org/t/production-optimizations/601/11?u=meln1k ↩︎\n https://forums.foundationdb.org/t/constrained-ram-in-an-application-development-environment/347/4?u=meln1k ↩︎\n https://forums.foundationdb.org/t/configuring-foundationdb-to-use-more-than-one-resolver/1414/2?u=meln1k ↩︎\n https://forums.foundationdb.org/t/production-optimizations/601/13?u=meln1k ↩︎\n  ","wordCount":"1501","inLanguage":"en","datePublished":"2019-06-15T14:20:32+02:00","dateModified":"2019-06-15T14:20:32+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://nikita.melkozerov.dev/posts/2019/06/building-a-foundationdb-cluster-roles-classes-and-processes/"},"publisher":{"@type":"Organization","name":"Nikita Melkozerov","logo":{"@type":"ImageObject","url":"https://nikita.melkozerov.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://nikita.melkozerov.dev/ accesskey=h title="Nikita Melkozerov (Alt + H)">Nikita Melkozerov</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://nikita.melkozerov.dev/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://nikita.melkozerov.dev/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://nikita.melkozerov.dev/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Building a FoundationDB Cluster: Roles, Classes, and Processes</h1><div class=post-description>How to prepare your FoundationDB cluster to run it in production and set up process classes to achieve maximum performance.</div><div class=post-meta>June 15, 2019&nbsp;·&nbsp;8 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#roles-classes-and-processes-in-foundationdb aria-label="Roles, Classes, and Processes in FoundationDB">Roles, Classes, and Processes in FoundationDB</a><ul><ul><li><a href=#out-of-clutter-find-simplicity aria-label="Out of clutter, find simplicity">Out of clutter, find simplicity</a></li><li><a href=#every-individual-has-a-role-to-play-for-the-betterment-of-our-cluster aria-label="Every individual has a role to play for the betterment of our cluster">Every individual has a role to play for the betterment of our cluster</a></li></ul></ul></li><li><a href=#requirements-and-resources aria-label="Requirements and resources">Requirements and resources</a></li><li><a href=#building-the-cluster aria-label="Building the cluster">Building the cluster</a><ul><ul><li><a href=#2-node-replication aria-label="2-node replication">2-node replication</a></li><li><a href=#3-node-replication aria-label="3-node replication">3-node replication</a></li></ul></ul></li></ul></div></details></div><div class=post-content><p>How to prepare your FoundationDB cluster to run it in production and set up process
classes to achieve maximum performance.</p><p><a href=https://www.foundationdb.org/>FoundationDB</a> is an outstanding database and it is a joy to use it as a developer. However, when it comes to running FDB in production, it is not always clear how many instances are needed and what classes should be assigned to processes. As of June 2019, FoundationDB doesn&rsquo;t (yet) have a &ldquo;smart&rdquo; tool that can automatically set the layout of the FDB cluster, and it is important to set the layout manually to achieve decent performance.</p><p>In this post, I&rsquo;ll writte about the best practices for configuring FDB cluster which I discovered while experimenting with the database and reading <a href=https://forums.foundationdb.org/>FoundationDB forums</a>.</p><h3 id=roles-classes-and-processes-in-foundationdb>Roles, Classes, and Processes in FoundationDB<a hidden class=anchor aria-hidden=true href=#roles-classes-and-processes-in-foundationdb>#</a></h3><p>FoundationDB server processes are identical binaries, but it is possible to assign a process to a specific <code>class</code> or a <code>role</code> to prioritize a specific workload. The difference between a <code>class</code> and a <code>role</code> is that assigning a class to a process specifies preference to recruit one of the corresponding roles (based on how good a particular role fits to a class), and assigning a role will result in a process preferring a single workload. The relationships between classes and roles are defined in the <a href=https://github.com/apple/foundationdb/blob/release-6.1/fdbrpc/Locality.cpp#L30>Locality.cpp</a> file.</p><h5 id=out-of-clutter-find-simplicity>Out of clutter, find simplicity<a hidden class=anchor aria-hidden=true href=#out-of-clutter-find-simplicity>#</a></h5><p>While no one prevents assigning a single role to a process, it is more flexible to assign <em>storage</em>, <em>transaction</em> and <em>stateless</em> classes to processes. Let&rsquo;s look at them more closely:</p><p><strong>Storage</strong> class: <strong>best fit</strong> for the <em>storage</em> role, <strong>worst fit</strong> for the <em>transaction log</em> role. Other roles won&rsquo;t be recruited in a process with this class.</p><p><strong>Transaction</strong> class: <strong>good fit</strong> for the <em>transaction log</em> role, <strong>okay fit</strong> for the <em>proxy</em>, <em>resolver</em>, <em>log router</em>, <em>cluster controller</em> roles, <strong>worst fit</strong> for the <em>storage</em> role.</p><p><strong>Stateless</strong> class: <strong>good fit</strong> for the <em>proxy</em>, <em>master</em>, <em>resolver</em>, <em>log router</em>, <em>cluster controller</em>, <em>data distributor</em>, and <em>ratekeeper</em> processes. <em>Storage</em> and <em>transaction log</em> roles won&rsquo;t be assigned to the stateless process.</p><p>When FDB tries to figure out which role it will recruit in a process, the fitness priority is used: <strong>best fit</strong> > <strong>good fit</strong> > <strong>okay fit</strong> > <strong>unset fit</strong> > <strong>worst fit</strong> > <strong>never assign</strong>. For example, if there are two processes which both have a <strong>transaction</strong> and a <strong>stateless</strong> class, the <em>proxy</em> role will be assigned to the <strong>stateless</strong> class since it fits better, even though <strong>transaction</strong> class is also suitable for this role.</p><p>Please note that assigning a role to the process will be treated as a class with the <strong>best fit</strong> for that role.</p><h5 id=every-individual-has-a-role-to-play-for-the-betterment-of-our-cluster>Every individual has a role to play for the betterment of our cluster<a hidden class=anchor aria-hidden=true href=#every-individual-has-a-role-to-play-for-the-betterment-of-our-cluster>#</a></h5><p>So, if a process will be recruited for a particular role, what will it do? Let&rsquo;s look at them one by one:</p><ul><li>Process with the <strong>storage</strong> role is responsible for storing key/value b-trees and serving reads to clients. It provides a consistent database snapshot for the last 5 seconds. A typical FDB cluster would have ~ 80-90% of all processes recruited as storage.</li><li>The <strong>transaction log</strong> process keeps an append-only log of mutations for ~ 7 seconds before the changes are pulled by the <strong>storage</strong> process, then deletes them. If a storage process is not able to pull the changes in time, the disk space used by log will grow.</li><li>The <strong>proxy</strong> sits between the client and transactional authority and coordinates the actions along the write transaction path. It also gives out recent read versions to the client.</li><li>The <strong>master</strong> keeps track of the commit version, assigns commit versions to transactions to provide global ordering.</li><li>The <strong>resolver</strong> checks transactions and aborts them if they&rsquo;re conflicting.</li><li>The <strong>data distributor</strong> is responsible for distributing data across shards.</li><li>The <strong>ratekeeper</strong> limits the transaction rate to prevent cluster overload.</li><li>The <strong>cluster controller</strong> knows the cluster configuration, provides it to new clients and reconfigures the cluster in the event of network disruption.</li><li>The <strong>log router</strong> will be recruited in remote datacenters for the purpose of supporting the log replication.</li></ul><p>Now that we know more about the classes, roles, and processes, let&rsquo;s see what resource requirements different roles have.</p><h3 id=requirements-and-resources>Requirements and resources<a hidden class=anchor aria-hidden=true href=#requirements-and-resources>#</a></h3><p>Different process roles consume different resources such as CPU, IOPS, network bandwidth and RAM, and we need to be careful to not create resource contention that will lead to reduced performance.</p><p>The <strong>transaction Log</strong> is both IOPS<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and bandwidth<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> hungry, and it&rsquo;s important to dedicate a whole disk for it. Memory consumption is ~ 1GB<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>The <strong>storage</strong> is not IOPS hungry but it can saturate the CPU, so it&rsquo;s better to not run the storage role in one process with others. If your SSD is fast enough, having more than one storage processes will utilize it better. It consumes less bandwidth than <strong>tLog</strong> or <strong>proxy</strong>, but it usually requires ~ 4GB of memory on average<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>The <strong>proxy</strong> is bandwidth<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> & CPU hungry, and it is important to give this role enough CPU to keep the latencies low.</p><p>The <strong>resolver</strong> is involved in checking conflict ranges and if you don&rsquo;t have conflicts then CPU consumption will be low<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. No high bandwidth or high IOPS consumption is expected, but the memory consumption can around 1GB<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>The rest of the stateless processes do not consume any significant resources and can be deployed without restrictions.</p><p>Based on the requirements above, there is a set of recommendations:</p><ol><li>Don&rsquo;t run <em>tLog</em> and <em>storage</em> on a single disk.</li><li>Don&rsquo;t run anything else in a single process that has <em>storage</em> or <em>proxy</em> roles since they&rsquo;re CPU hungry.</li><li>Run each <em>proxy</em> on a different host.</li><li>It might be useful to dedicate a separate host for <em>tLog</em> due to its bandwidth consumption.</li><li>Don&rsquo;t leave unspecified processes as FDB will recruit a storage role there by default<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>, and this can increase latency for other roles in this process.</li></ol><p>These are not hard rules but rather recommendations that should improve the performance of your cluster. For example, if a <em>proxy</em> is consuming the whole CPU core but the network is not saturated, it makes sense to run another proxy process on the same host.</p><h3 id=building-the-cluster>Building the cluster<a hidden class=anchor aria-hidden=true href=#building-the-cluster>#</a></h3><p>Given that we understand more about roles and their requirements, let&rsquo;s see what might be reasonable cluster layouts.</p><h5 id=2-node-replication>2-node replication<a hidden class=anchor aria-hidden=true href=#2-node-replication>#</a></h5><p>If we want to tolerate a single machine failure (and make progress after such failure), we need 3 machines with 2 copy replication. However, for performance reasons, we should not share disks between <em>tLog</em> and <em>storage</em> roles. It means that we should have 6 separate disks. Often, cloud providers will give only one disk per node, that&rsquo;s why we need at least six different nodes to prevent performance penalties in the event of failure.</p><p>A minimal Layout #1: 6 nodes, 2 processes in each node:</p><ul><li>tLog master</li><li>tLog cluster_controller</li><li>tLog stateless</li><li>storage proxy</li><li>storage proxy</li><li>storage stateless</li></ul><p>In this layout, we try to utilize the network bandwidth as much as possible by placing <em>tLogs</em> and <em>proxies</em> on different nodes, and at the same time, we don&rsquo;t have a performance loss in case of failure because we have extra <em>tLog</em> and <em>storage</em> processes. You can easily scale this cluster by adding more <em>storage</em> processes, and adding more <em>tLog</em>, <em>proxies</em>, and <em>resolver</em> if they&rsquo;re overloaded.</p><p>A minimal Layout #2: 5 nodes, 2 processes in each node:</p><ul><li>tLog master</li><li>tLog cluster_controller</li><li>storage proxy</li><li>storage proxy</li><li>storage stateless</li></ul><p>Here we use fewer nodes, however, if tLog fails FDB will relocate the missing tLog to the same process together with a storage role. This will degrade the performance and increase latencies until the node is back.</p><p>Please note that the ratio of <em>tLog</em> : <em>storage</em> is not optimal here and it&rsquo;s done this way purely due to fault tolerance concerns. Usually, you need more <em>storage</em> processes than <em>tLog</em> processes. It depends on your workload though, if you have lots of heavy writes, then having more <em>tLog</em> processes is better.</p><p>Also, don&rsquo;t forget to configure three coordinators to keep the cluster running in the event of a node failure.</p><h5 id=3-node-replication>3-node replication<a hidden class=anchor aria-hidden=true href=#3-node-replication>#</a></h5><p>If you&rsquo;re unsure about the reliability of the available hosts, it is possible to use 3-node replication. Again, I&rsquo;m making this layout given that only 1 disk is available per host, therefore we need to have 4 hosts for each <em>tLog</em> and <em>storage</em> role.</p><p>A minimal Layout #3: 8 nodes, 2 processes in each node:</p><ul><li>tLog master</li><li>tLog cluster_controller</li><li>tLog stateless</li><li>tLog stateless</li><li>storage proxy</li><li>storage proxy</li><li>storage proxy</li><li>storage resolution</li></ul><p>With this layout we don&rsquo;t share a node between the <em>proxy</em> and the <em>tLog</em>, disks aren&rsquo;t shared between stateful processes, and every process has a set class so FDB won&rsquo;t spawn a <em>storage</em> process where we wouldn&rsquo;t expect it. We already have quite some <em>tLog</em> roles here, so to scale this cluster we should add more <em>storage</em> nodes.</p><p>That&rsquo;s all, folks. I hope these layouts will make it easier to bootstrap a FoundationDB cluster. Do you have other cool ideas about the possible cluster layouts? Please share them in the comments!</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href="https://forums.foundationdb.org/t/production-deployment/522/4?u=meln1k">https://forums.foundationdb.org/t/production-deployment/522/4?u=meln1k</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p><a href="https://forums.foundationdb.org/t/production-optimizations/601/11?u=meln1k">https://forums.foundationdb.org/t/production-optimizations/601/11?u=meln1k</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p><a href="https://forums.foundationdb.org/t/constrained-ram-in-an-application-development-environment/347/4?u=meln1k">https://forums.foundationdb.org/t/constrained-ram-in-an-application-development-environment/347/4?u=meln1k</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p><a href="https://forums.foundationdb.org/t/configuring-foundationdb-to-use-more-than-one-resolver/1414/2?u=meln1k">https://forums.foundationdb.org/t/configuring-foundationdb-to-use-more-than-one-resolver/1414/2?u=meln1k</a> <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p><a href="https://forums.foundationdb.org/t/production-optimizations/601/13?u=meln1k">https://forums.foundationdb.org/t/production-optimizations/601/13?u=meln1k</a> <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><footer class=post-footer><ul class=post-tags><li><a href=https://nikita.melkozerov.dev/tags/foundationdb/>foundationdb</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://nikita.melkozerov.dev/>Nikita Melkozerov</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>