<!DOCTYPE html>
<html lang="en-us">

  
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Nikita Melkozerov">
  <meta name="generator" content="Hugo 0.55.5" />
  <title>Building a FoundationDB Cluster: Roles, Classes, and Processes — Nikita Melkozerov</title>

  <meta name="description" content="How to prepare your FoundationDB cluster to run it in production and set up process classes to achieve maximum performance.">
  <link rel="canonical" href="http://nikita.melkozerov.dev/posts/2019/06/building-a-foundationdb-cluster-roles-classes-and-processes/">
  <link href="" rel="alternate" type="application/rss+xml" title="Nikita Melkozerov">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,700|Source+Code+Pro|Arvo:700">
  <link rel="stylesheet" href="http://nikita.melkozerov.dev/css/paperback.css">
</head>


  <body>
    <div class="container">

      <header>
  <h1>Building a FoundationDB Cluster: Roles, Classes, and Processes</h1>

  
  <time datetime="2019-06-15 14:20:32 &#43;0200 CEST">2019/06/15</time>
  

  
</header>


      <article>
        <p>How to prepare your FoundationDB cluster to run it in production and set up process
classes to achieve maximum performance.</p>

<p><a href="https://www.foundationdb.org/">FoundationDB</a> is an outstanding database and it is a  joy to use it as a developer. However, when it comes to running FDB in production, it is not always clear how many instances are needed and what classes should be assigned to processes. As of June 2019, FoundationDB doesn&rsquo;t (yet) have a &ldquo;smart&rdquo; tool that can automatically set the layout of the FDB cluster, and it is important to set the layout manually to achieve decent performance.</p>

<p>In this post, I&rsquo;ll writte about the best practices for configuring FDB cluster which I discovered while experimenting with the database and reading <a href="https://forums.foundationdb.org/">FoundationDB forums</a>.</p>

<h3 id="roles-classes-and-processes-in-foundationdb">Roles, Classes, and Processes in FoundationDB</h3>

<p>FoundationDB server processes are identical binaries, but it is possible to assign a process to a specific <code>class</code> or a <code>role</code> to prioritize a specific workload. The difference between a <code>class</code> and a <code>role</code> is that assigning a class to a process specifies preference to recruit one of the corresponding roles (based on how good a particular role fits to a class), and assigning a role will result in a process preferring a single workload. The relationships between classes and roles are defined in the <a href="https://github.com/apple/foundationdb/blob/release-6.1/fdbrpc/Locality.cpp#L30">Locality.cpp</a> file.</p>

<h5 id="out-of-clutter-find-simplicity">Out of clutter, find simplicity</h5>

<p>While no one prevents assigning a single role to a process, it is more flexible to assign <em>storage</em>, <em>transaction</em> and <em>stateless</em> classes to processes. Let&rsquo;s look at them more closely:</p>

<p><strong>Storage</strong> class: <strong>best fit</strong> for the <em>storage</em> role, <strong>worst fit</strong> for the <em>transaction log</em> role. Other roles won&rsquo;t be recruited in a process with this class.</p>

<p><strong>Transaction</strong> class: <strong>good fit</strong> for the <em>transaction log</em> role, <strong>okay fit</strong> for the <em>proxy</em>, <em>resolver</em>, <em>log router</em>, <em>cluster controller</em> roles, <strong>worst fit</strong> for the <em>storage</em> role.</p>

<p><strong>Stateless</strong> class: <strong>good fit</strong> for the <em>proxy</em>, <em>master</em>, <em>resolver</em>, <em>log router</em>, <em>cluster controller</em>, <em>data distributor</em>, and <em>ratekeeper</em> processes. <em>Storage</em> and <em>transaction log</em> roles won&rsquo;t be assigned to the stateless process.</p>

<p>When FDB tries to figure out which role it will recruit in a process, the fitness priority is used: <strong>best fit</strong> &gt; <strong>good fit</strong> &gt; <strong>okay fit</strong> &gt; <strong>unset fit</strong> &gt; <strong>worst fit</strong> &gt; <strong>never assign</strong>. For example, if there are two processes which both have a <strong>transaction</strong> and a <strong>stateless</strong> class, the <em>proxy</em> role will be assigned to the <strong>stateless</strong> class since it fits better, even though <strong>transaction</strong> class is also suitable for this role.</p>

<p>Please note that assigning a role to the process will be treated as a class with the <strong>best fit</strong> for that role.</p>

<h5 id="every-individual-has-a-role-to-play-for-the-betterment-of-our-cluster">Every individual has a role to play for the betterment of our cluster</h5>

<p>So, if a process will be recruited for a particular role, what will it do? Let&rsquo;s look at them one by one:</p>

<ul>
<li>Process with the <strong>storage</strong> role is responsible for storing key/value b-trees and serving reads to clients. It provides a consistent database snapshot for the last 5 seconds. A typical FDB cluster would have ~ 80-90% of all processes recruited as storage.</li>
<li>The <strong>transaction log</strong> process keeps an append-only log of mutations for ~ 7 seconds before the changes are pulled by the <strong>storage</strong> process, then deletes them. If a storage process is not able to pull the changes in time, the disk space used by log will grow.</li>
<li>The <strong>proxy</strong> sits between the client and transactional authority and coordinates the actions along the write transaction path. It also gives out recent read versions to the client.</li>
<li>The <strong>master</strong> keeps track of the commit version, assigns commit versions to transactions to provide global ordering.</li>
<li>The <strong>resolver</strong> checks transactions and aborts them if they&rsquo;re conflicting.</li>
<li>The <strong>data distributor</strong> is responsible for distributing data across shards.</li>
<li>The <strong>ratekeeper</strong> limits the transaction rate to prevent cluster overload.</li>
<li>The <strong>cluster controller</strong> knows the cluster configuration, provides it to new clients and reconfigures the cluster in the event of network disruption.</li>
<li>The <strong>log router</strong> will be recruited in remote datacenters for the purpose of supporting the log replication.</li>
</ul>

<p>Now that we know more about the classes, roles, and processes, let&rsquo;s see what resource requirements different roles have.</p>

<h3 id="requirements-and-resources">Requirements and resources</h3>

<p>Different process roles consume different resources such as CPU, IOPS, network bandwidth and RAM, and we need to be careful to not create resource contention that will lead to reduced performance.</p>

<p>The <strong>transaction Log</strong> is both IOPS<sup class="footnote-ref" id="fnref:1"><a href="#fn:1">1</a></sup> and bandwidth<sup class="footnote-ref" id="fnref:2"><a href="#fn:2">2</a></sup> hungry, and it&rsquo;s important to dedicate a whole disk for it. Memory consumption is ~ 1GB<sup class="footnote-ref" id="fnref:4"><a href="#fn:4">3</a></sup>.</p>

<p>The <strong>storage</strong> is not IOPS hungry but it can saturate the CPU, so it&rsquo;s better to not run the storage role in one process with others. If your SSD is fast enough, having more than one storage processes will utilize it better. It consumes less bandwidth than <strong>tLog</strong> or <strong>proxy</strong>, but it usually requires ~ 4GB of memory on average<sup class="footnote-ref" id="fnref:4"><a href="#fn:4">3</a></sup>.</p>

<p>The <strong>proxy</strong> is bandwidth<sup class="footnote-ref" id="fnref:2"><a href="#fn:2">2</a></sup> &amp; CPU hungry, and it is important to give this role enough CPU to keep the latencies low.</p>

<p>The <strong>resolver</strong> is involved in checking conflict ranges and if you don&rsquo;t have conflicts then CPU consumption will be low<sup class="footnote-ref" id="fnref:3"><a href="#fn:3">4</a></sup>. No high bandwidth or high IOPS consumption is expected, but the memory consumption can around 1GB<sup class="footnote-ref" id="fnref:4"><a href="#fn:4">3</a></sup>.</p>

<p>The rest of the stateless processes do not consume any significant resources and can be deployed without restrictions.</p>

<p>Based on the requirements above, there is a set of recommendations:</p>

<ol>
<li>Don&rsquo;t run <em>tLog</em> and <em>storage</em> on a single disk.</li>
<li>Don&rsquo;t run anything else in a single process that has <em>storage</em> or <em>proxy</em> roles since they&rsquo;re CPU hungry.</li>
<li>Run each <em>proxy</em> on a different host.</li>
<li>It might be useful to dedicate a separate host for <em>tLog</em> due to its bandwidth consumption.</li>
<li>Don&rsquo;t leave unspecified processes as FDB will recruit a storage role there by default<sup class="footnote-ref" id="fnref:5"><a href="#fn:5">5</a></sup>, and this can increase latency for other roles in this process.</li>
</ol>

<p>These are not hard rules but rather recommendations that should improve the performance of your cluster. For example, if a <em>proxy</em> is consuming the whole CPU core but the network is not saturated, it makes sense to run another proxy process on the same host.</p>

<h3 id="building-the-cluster">Building the cluster</h3>

<p>Given that we understand more about roles and their requirements, let&rsquo;s see what might be reasonable cluster layouts.</p>

<h5 id="2-node-replication">2-node replication</h5>

<p>If we want to tolerate a single machine failure (and make progress after such failure), we need 3 machines with 2 copy replication. However, for performance reasons, we should not share disks between <em>tLog</em> and <em>storage</em> roles. It means that we should have 6 separate disks. Often, cloud providers will give only one disk per node, that&rsquo;s why we need at least six different nodes to prevent performance penalties in the event of failure.</p>

<p>A minimal Layout #1: 6 nodes, 2 processes in each node:</p>

<ul>
<li>tLog master</li>
<li>tLog cluster_controller</li>
<li>tLog stateless</li>
<li>storage proxy</li>
<li>storage proxy</li>
<li>storage stateless</li>
</ul>

<p>In this layout, we try to utilize the network bandwidth as much as possible by placing <em>tLogs</em> and <em>proxies</em> on different nodes, and at the same time, we don&rsquo;t have a performance loss in case of failure because we have extra <em>tLog</em> and <em>storage</em> processes. You can easily scale this cluster by adding more <em>storage</em> processes, and adding more <em>tLog</em>, <em>proxies</em>, and <em>resolver</em> if they&rsquo;re overloaded.</p>

<p>A minimal Layout #2: 5 nodes, 2 processes in each node:</p>

<ul>
<li>tLog master</li>
<li>tLog cluster_controller</li>
<li>storage proxy</li>
<li>storage proxy</li>
<li>storage stateless</li>
</ul>

<p>Here we use fewer nodes, however, if tLog fails FDB will relocate the missing tLog to the same process together with a storage role. This will degrade the performance and increase latencies until the node is back.</p>

<p>Please note that the ratio of <em>tLog</em> : <em>storage</em> is not optimal here and it&rsquo;s done this way purely due to fault tolerance concerns. Usually, you need more <em>storage</em> processes than <em>tLog</em> processes. It depends on your workload though, if you have lots of heavy writes, then having more <em>tLog</em> processes is better.</p>

<p>Also, don&rsquo;t forget to configure three coordinators to keep the cluster running in the  event of a node failure.</p>

<h5 id="3-node-replication">3-node replication</h5>

<p>If you&rsquo;re unsure about the reliability of the available hosts, it is possible to use 3-node replication. Again, I&rsquo;m making this layout given that only 1 disk is available per host, therefore we need to have 4 hosts for each <em>tLog</em> and <em>storage</em> role.</p>

<p>A minimal Layout #3: 8 nodes, 2 processes in each node:</p>

<ul>
<li>tLog master</li>
<li>tLog cluster_controller</li>
<li>tLog stateless</li>
<li>tLog stateless</li>
<li>storage proxy</li>
<li>storage proxy</li>
<li>storage proxy</li>
<li>storage resolution</li>
</ul>

<p>With this layout we don&rsquo;t share a node between the <em>proxy</em> and the <em>tLog</em>, disks aren&rsquo;t shared between stateful processes, and every process has a set class so FDB won&rsquo;t spawn a <em>storage</em> process where we wouldn&rsquo;t expect it. We already have quite some <em>tLog</em> roles here, so to scale this cluster we should add more <em>storage</em> nodes.</p>

<p>That&rsquo;s all, folks. I hope these layouts will make it easier to bootstrap a FoundationDB cluster. Do you have other cool ideas about the possible cluster layouts? Please share them in the comments!</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1"><a href="https://forums.foundationdb.org/t/production-deployment/522/4?u=meln1k">https://forums.foundationdb.org/t/production-deployment/522/4?u=meln1k</a>
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
<li id="fn:2"><a href="https://forums.foundationdb.org/t/production-optimizations/601/11?u=meln1k">https://forums.foundationdb.org/t/production-optimizations/601/11?u=meln1k</a>
 <a class="footnote-return" href="#fnref:2"><sup>[return]</sup></a></li>
<li id="fn:4"><a href="https://forums.foundationdb.org/t/constrained-ram-in-an-application-development-environment/347/4?u=meln1k">https://forums.foundationdb.org/t/constrained-ram-in-an-application-development-environment/347/4?u=meln1k</a>
 <a class="footnote-return" href="#fnref:4"><sup>[return]</sup></a></li>
<li id="fn:3"><a href="https://forums.foundationdb.org/t/configuring-foundationdb-to-use-more-than-one-resolver/1414/2?u=meln1k">https://forums.foundationdb.org/t/configuring-foundationdb-to-use-more-than-one-resolver/1414/2?u=meln1k</a>
 <a class="footnote-return" href="#fnref:3"><sup>[return]</sup></a></li>
<li id="fn:5"><a href="https://forums.foundationdb.org/t/production-optimizations/601/13?u=meln1k">https://forums.foundationdb.org/t/production-optimizations/601/13?u=meln1k</a>
 <a class="footnote-return" href="#fnref:5"><sup>[return]</sup></a></li>
</ol>
</div>
      </article>

      <section class="comments-block">
      <button id="show-comments" class="comments-button" style="display: none;">Load Disqus Comments</button>
</section>

<section id="disqus_thread"></section>

<script>
      (function () {
            
            
            if (window.location.hostname == "localhost")
                  return;
            var disqus_loaded = false;
            var disqus_shortname = 'meln1k';
            var disqus_button = document.getElementById("show-comments");
            disqus_button.style.display = "";
            disqus_button.addEventListener("click", disqus, false);
            function disqus() {
                  if (!disqus_loaded) {
                        disqus_loaded = true;
                        var e = document.createElement("script");
                        e.type = "text/javascript";
                        e.async = true;
                        e.src = "//" + disqus_shortname + ".disqus.com/embed.js";
                        (document.getElementsByTagName("head")[0] ||
                              document.getElementsByTagName("body")[0])
                        .appendChild(e);
                        
                        document.getElementById("show-comments").style.display = "none";
                  }
            }
            
            var hash = window.location.hash.substr(1);
            if (hash.length > 8) {
                  if (hash.substring(0, 8) == "comment-") {
                        disqus();
                  }
            }
      })();
</script>


      <nav class="site-nav">
  <a href="http://nikita.melkozerov.dev/">Home</a>
  <a href="http://nikita.melkozerov.dev/posts/">All posts</a>

  
  <a href="https://twitter.com/meln1k">Twitter</a>

  
  <a href="https://github.com/meln1k">GitHub</a>

  
  <a href="https://www.linkedin.com/in/nmelkozerov">LinkedIn</a>
</nav>


      <footer class="site-footer">
  <span class="owner">©2019 Nikita Melkozerov</span>
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-59947059-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  
  
</footer>


    </div>

  </body>
</html>
